## БД
### Выбор базы данных
В качестве базы данных была выбрана H2(её in-memory вариант), т.к. она значительно упрощает тестирование,
а ее возможностей вполне хватит для поставленных задач.
### Миграция
При запуске приложения происходит миграция БД с использованием Flyway, чтобы создать необходимую структуру БД
### DAO
В качестве инструмента для доступа к данным используются Spring Data Repositories, которые удобны при разработке,
но могут стать нечитаемыми при злоупотреблением QueryMethods, поэтому между ними и слоем бизнес логики был добавлен 
слой DAO. Также он позволяет не привязываться к специфичным классам Spring Data Repositories(например PageRequest).
## Создание заявки
Для создания заявки необходимо отправить POST запрос по адресу `localhost:8080/tickets` с телом, содержащим JSON следующего
вида:
```
{
    "routeNumber": "testNumber",
    "departureDate": "2019-08-05T18:05"
}
```
### Валидация
* Поле `routeNumber`:
  * Обязательно
  * Должно содержать строку длиной от 1 до 20 символов
* Поле `departureDate`:
  * Обязательно
  * Содержит дату в формате `yyyy-MM-ddTHH:mm:ss` (`java.time.format.DateTimeFormatter.ISO_LOCAL_DATE_TIME`)

При нарушении даных правил заявка не создастся, клиенту вернется ответ со статусом 400 и описанием ошибки
## Получение статуса заявки
Для получения статуса заявки необходимо отправить GET запрос по адресу `localhost:8080/tickets/{ticketId}/status`,
где `{ticketId}` - ID нужной заявки
### Ответы
* `200` - Заявка найдена, ее статус возвращен в ответе
* `404` - заявка не найдена
## Сервис платежей
Сервис платежей был реализован в этом же приложении отдельным endpoint-ом и доступен по адресу `localhost:8080/payments`.
Для проведения оплаты по заявке необходимо отправить POST запрос по адресу `localhost:8080/payments/process/{ticketId}`,
где `{ticketId}` - ID нужной заявки
## Проблема долгой обработки платежей
В теории возможна ситуация, что обработка платежа займет > 1 минуты, что может привести к тому, что одна и та же заявка обработается
несколько раз, что приведет ее в неверное состояние(статус перепишется). Возможным решением может быть использование Event Driven подхода с 
использованием Kafka(или подобного инструмента). В таком случае запрос о проведении платежа и ответ об изменении его статуса будут помещаться в соответствующие очереди.
А сервис проведения платежей уже будет контролировать, повторные запросы(возможно, ведя их историю и проверяя следует ли обрабатывать новый запрос
из очереди или нет).